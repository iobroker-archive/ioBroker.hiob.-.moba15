{
  "version": 3,
  "sources": ["../../src/server/server.ts"],
  "sourcesContent": ["import * as ws from 'ws';\nimport * as fs from 'fs';\nimport { createServer } from 'https';\nimport type * as m from '../main';\nimport { Client } from './client';\nimport { FirstPingPack } from './datapacks';\nimport { Mutex } from 'async-mutex';\nexport class Server {\n    certPath: string;\n    keyPath: string;\n    useCert: boolean;\n    port: number;\n    adapter: m.SamartHomeHandyBis;\n    socket: ws.Server | undefined;\n    stoped: boolean = false;\n    clientMutex = new Mutex();\n    conClients: {\n        client: Client;\n        lastPong: boolean;\n    }[] = [];\n    messageBacklogForClient: {\n        clientId: string;\n        backlog: any[];\n    }[] = [];\n    pingPongInterval: ioBroker.Interval | undefined;\n    constructor(\n        port: number = 4500,\n        keyPath: string = 'key.pem',\n        certPath: string = 'cert.pem',\n        adapter: m.SamartHomeHandyBis,\n        useCert: boolean = false,\n    ) {\n        this.port = port;\n        this.certPath = certPath;\n        this.keyPath = keyPath;\n        this.adapter = adapter;\n        this.useCert = useCert;\n    }\n\n    startServer(): void {\n        let server;\n\n        if (this.useCert) {\n            server = createServer({\n                cert: fs.readFileSync(this.certPath),\n                key: fs.readFileSync(this.keyPath),\n            });\n            this.adapter.log.info('[Server] Starting secure server...');\n            this.socket = new ws.Server({ server: server });\n        } else {\n            this.adapter.log.info('[Server] Starting server...');\n            this.socket = new ws.Server({ port: this.port });\n        }\n        this.socket.on('error', e => {\n            this.adapter.log.info(`error: ${e.message}`);\n            this.adapter.setState('info.connection', false, true);\n        });\n        this.adapter.setState('info.connection', true, true);\n        this.socket.on('connection', (socket: ws.WebSocket, req) => {\n            this.adapter.log.debug('Client connected');\n            this.conClients.push({\n                client: new Client(socket, this, req, this.adapter),\n                lastPong: true,\n            });\n            socket.send(new FirstPingPack().toJSON());\n        });\n        server?.listen(this.port);\n        this.adapter.log.info(`Server started and is listening on port: ${this.port}`);\n        this.stoped = false;\n        this.startPingPong();\n    }\n\n    startPingPong(): void {\n        this.pingPongInterval = this.adapter.setInterval(this.pingAll.bind(this), 15 * 1000);\n    }\n\n    private async pingAll(): Promise<void> {\n        await this.clientMutex.runExclusive(() => {\n            this.conClients = this.conClients.filter(e => {\n                if (e.lastPong) {\n                    return true;\n                }\n                e.client.onEnd();\n                let backlog = this.messageBacklogForClient.find(c => c.clientId == e.client.id);\n                if (!backlog) {\n                    backlog = { clientId: e.client.id!, backlog: [] };\n                    this.messageBacklogForClient.push(backlog);\n                }\n                e.client.messageHistoryMutex.runExclusive(() => {\n                    backlog.backlog.push(...e.client.messageHistory);\n                });\n                //If there are 2 clients \"connected\" at the same time. This could happen for a short period of time\n                this.sendBacklog(e.client);\n\n                return false;\n            });\n        });\n        this.adapter.log.debug(`Size: ${this.conClients.length.toString()}`);\n\n        this.conClients.forEach(e => {\n            e.lastPong = false;\n            e.client.socket.ping();\n        });\n    }\n\n    sendBacklog(client: Client): void {\n        //TODO: Discuss if this would be thread safe. There should only be one client connected (with the same id), so this should be no problem?\n        const backlog = this.messageBacklogForClient.find(e => e.clientId == client.id);\n        backlog?.backlog.forEach(msg => client.sendMSG(msg, true));\n        if (backlog) {\n            backlog.backlog = [];\n        }\n    }\n\n    broadcastMsg(msg: string): void {\n        //this.webSocketServer.clients.forEach((e) => {});\n        this.conClients\n            .filter(e => !e.client.onlySendNotification)\n            .forEach(element => {\n                if (element.client.isConnected) {\n                    element.client.sendMSG(msg, true);\n                }\n            });\n    }\n\n    isConnected(deviceID: string): boolean {\n        return this.conClients.some(c => c.client.isConnected && c.client.id == deviceID);\n    }\n\n    getClient(deviceID: string): Client | undefined {\n        return this.conClients.find(c => c.client.isConnected && c.client.id == deviceID)?.client;\n    }\n    getClients(deviceID: string): Client[] {\n        return this.conClients.filter(c => c.client.isConnected && c.client.id == deviceID).map(e => e.client);\n    }\n\n    stop(): void {\n        this.socket?.close();\n        this.adapter.log.info('Server stoped');\n        this.stoped = true;\n        this.adapter.clearInterval(this.pingPongInterval);\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
