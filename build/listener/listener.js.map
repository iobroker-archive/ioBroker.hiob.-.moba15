{
  "version": 3,
  "sources": ["../../src/listener/listener.ts"],
  "sourcesContent": ["import { EventEmitter } from 'stream';\nimport type { SamartHomeHandyBis } from '../main';\nimport { StateChangedDataPack } from '../server/datapacks';\nimport { Mutex } from 'async-mutex';\n\nexport enum Events {\n    StateChange = 'stateChanged',\n}\n\nexport class Listener extends EventEmitter {\n    static subscribtionThresholdPerInstance = 15;\n    adapter: SamartHomeHandyBis;\n    busy: boolean = false;\n    subsribedStates: Map<\n        string,\n        {\n            overThreshold: boolean;\n            subscribed: Set<string>;\n            pending: Set<string>;\n        }\n    > = new Map();\n    subscribedStates: Set<string> = new Set();\n    pendingSubscribeStates: Set<string> = new Set();\n    mutex: Mutex = new Mutex();\n    constructor(adapter: SamartHomeHandyBis) {\n        super();\n        this.adapter = adapter;\n    }\n\n    onStateChange(id: string, state: ioBroker.State | null | undefined): void {\n        if (state != null) {\n            // The state was changed\n            //this.log.info(`state ${id} changed: ${state.val} (ack = ${state.ack})`);\n            //Check if notification\n            if (!id.startsWith('hiob.')) {\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                const adapaterKey = `${id.split('.')[0]}.${id.split('.')[1]}`;\n                if (this.subsribedStates.get(adapaterKey)?.subscribed.has(id)) {\n                    if (this.adapter.valueDatapoints[id] == null) {\n                        this.adapter.valueDatapoints[id] = {};\n                    }\n                    this.adapter.valueDatapoints[id].val = state.val;\n                    this.adapter.valueDatapoints[id].ack = state.ack;\n                    this.adapter.server?.broadcastMsg(\n                        new StateChangedDataPack(id, state.val, state.ack, state.lc, state.ts).toJSON(),\n                    );\n                }\n            }\n            this.emit(Events.StateChange, new StateChangeEvent(id, state.val, state.ack));\n        } else {\n            this.emit('stateDeleted', new StateChangeEvent(id, null, null));\n            this.adapter.log.info(`state ${id} deleted`);\n        }\n    }\n    /**\n     * Adds a State id to the pending list\n     *\n     * @param id The id of the State you want to subscribe to\n     */\n    addPendingSubscribeState(id: string): void {\n        this.mutex.runExclusive(() => {\n            if (this.subscribedStates.has(id)) {\n                return;\n            }\n            this.pendingSubscribeStates.add(id);\n            const adapaterKey = `${id.split('.')[0]}.${id.split('.')[1]}`;\n            if (this.subsribedStates.has(adapaterKey)) {\n                const t = this.subsribedStates.get(adapaterKey);\n                if (!t!.subscribed.has(id)) {\n                    t?.pending.add(id);\n                } else {\n                    this.adapter.log.debug(`Already has subscribed to ${id}!`);\n                }\n            } else {\n                this.subsribedStates.set(adapaterKey, {\n                    overThreshold: false,\n                    subscribed: new Set(),\n                    pending: new Set([id]),\n                });\n            }\n        });\n    }\n    /**\n     * Subscribes to all States listed in the pending (see addPendingSubscribeState)\n     * If there are more than 50 subscriptions for one instance it subscribses to all changes inside this instance\n     */\n    subscribeToPendingStates(): void {\n        this.mutex.runExclusive(async () => {\n            if (this.subscribedStates.size >= Listener.subscribtionThresholdPerInstance) {\n                this.pendingSubscribeStates.forEach(e => this.subscribedStates.add(e));\n                this.pendingSubscribeStates.clear();\n            } else {\n                /* if(this.subscribedStates.size + this.pendingSubscribeStates.size >= Listener.subscribtionThresholdPerInstance) {\n                    this.adapter.log.debug(\"More than 50 states. Subscribing to *\")\n                    await this.adapter.subscribeForeignStatesAsync(\"*\");\n                    this.subscribedStates.forEach((e) => this.adapter.unsubscribeForeignStatesAsync(e));\n                    this.pendingSubscribeStates.forEach((e) => this.subscribedStates.add(e));\n                } else {\n                    this.pendingSubscribeStates.forEach((e) => this.adapter.subscribeForeignStatesAsync(e));\n                }\n                this.pendingSubscribeStates.clear();*/\n\n                for (const [adapaterKey, subsribedStatesStatus] of this.subsribedStates) {\n                    if (subsribedStatesStatus.pending.size > 0) {\n                        if (subsribedStatesStatus.overThreshold) {\n                            subsribedStatesStatus.pending.forEach(e => subsribedStatesStatus.subscribed.add(e));\n                        } else {\n                            const newSubscriptionSize =\n                                subsribedStatesStatus.pending.size + subsribedStatesStatus.subscribed.size;\n                            if (\n                                newSubscriptionSize > Listener.subscribtionThresholdPerInstance &&\n                                !adapaterKey.startsWith('alias.')\n                            ) {\n                                subsribedStatesStatus.pending.forEach(e => {\n                                    subsribedStatesStatus.subscribed.add(e);\n                                });\n                                this.adapter.log.debug(\n                                    `More than ${Listener.subscribtionThresholdPerInstance} states of ${\n                                        adapaterKey\n                                    } were subscribed. Now only listening to ${adapaterKey}.*`,\n                                );\n                                //subscribe to * instead\n                                await this.adapter.subscribeForeignStatesAsync(`${adapaterKey}.*`);\n                                //Unsubscribe to the exesting subscriptions\n                                for (const i of subsribedStatesStatus.subscribed) {\n                                    this.adapter.unsubscribeForeignStatesAsync(i);\n                                }\n                            } else {\n                                subsribedStatesStatus.pending.forEach(e => {\n                                    subsribedStatesStatus.subscribed.add(e);\n                                    this.adapter.subscribeForeignStates(e);\n                                });\n                            }\n                        }\n                        subsribedStatesStatus.pending.clear();\n                    }\n                }\n            }\n        });\n    }\n}\n\nexport class StateChangeEvent {\n    objectID: string;\n    value: any;\n    ack: any;\n    constructor(\n        objectID: string,\n        value: string | number | boolean | undefined | null,\n        ack: boolean | undefined | null,\n    ) {\n        this.objectID = objectID;\n        this.value = value;\n        this.ack = ack;\n    }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oBAA6B;AAE7B,uBAAqC;AACrC,yBAAsB;AAEf,IAAK,SAAL,kBAAKA,YAAL;AACH,EAAAA,QAAA,iBAAc;AADN,SAAAA;AAAA,GAAA;AAIL,MAAM,YAAN,MAAM,kBAAiB,2BAAa;AAAA,EAevC,YAAY,SAA6B;AACrC,UAAM;AAbV,gBAAgB;AAChB,2BAOI,oBAAI,IAAI;AACZ,4BAAgC,oBAAI,IAAI;AACxC,kCAAsC,oBAAI,IAAI;AAC9C,iBAAe,IAAI,yBAAM;AAGrB,SAAK,UAAU;AAAA,EACnB;AAAA,EAEA,cAAc,IAAY,OAAgD;AA7B9E;AA8BQ,QAAI,SAAS,MAAM;AAIf,UAAI,CAAC,GAAG,WAAW,OAAO,GAAG;AAEzB,cAAM,cAAc,GAAG,GAAG,MAAM,GAAG,EAAE,CAAC,CAAC,IAAI,GAAG,MAAM,GAAG,EAAE,CAAC,CAAC;AAC3D,aAAI,UAAK,gBAAgB,IAAI,WAAW,MAApC,mBAAuC,WAAW,IAAI,KAAK;AAC3D,cAAI,KAAK,QAAQ,gBAAgB,EAAE,KAAK,MAAM;AAC1C,iBAAK,QAAQ,gBAAgB,EAAE,IAAI,CAAC;AAAA,UACxC;AACA,eAAK,QAAQ,gBAAgB,EAAE,EAAE,MAAM,MAAM;AAC7C,eAAK,QAAQ,gBAAgB,EAAE,EAAE,MAAM,MAAM;AAC7C,qBAAK,QAAQ,WAAb,mBAAqB;AAAA,YACjB,IAAI,sCAAqB,IAAI,MAAM,KAAK,MAAM,KAAK,MAAM,IAAI,MAAM,EAAE,EAAE,OAAO;AAAA;AAAA,QAEtF;AAAA,MACJ;AACA,WAAK,KAAK,kCAAoB,IAAI,iBAAiB,IAAI,MAAM,KAAK,MAAM,GAAG,CAAC;AAAA,IAChF,OAAO;AACH,WAAK,KAAK,gBAAgB,IAAI,iBAAiB,IAAI,MAAM,IAAI,CAAC;AAC9D,WAAK,QAAQ,IAAI,KAAK,SAAS,EAAE,UAAU;AAAA,IAC/C;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,yBAAyB,IAAkB;AACvC,SAAK,MAAM,aAAa,MAAM;AAC1B,UAAI,KAAK,iBAAiB,IAAI,EAAE,GAAG;AAC/B;AAAA,MACJ;AACA,WAAK,uBAAuB,IAAI,EAAE;AAClC,YAAM,cAAc,GAAG,GAAG,MAAM,GAAG,EAAE,CAAC,CAAC,IAAI,GAAG,MAAM,GAAG,EAAE,CAAC,CAAC;AAC3D,UAAI,KAAK,gBAAgB,IAAI,WAAW,GAAG;AACvC,cAAM,IAAI,KAAK,gBAAgB,IAAI,WAAW;AAC9C,YAAI,CAAC,EAAG,WAAW,IAAI,EAAE,GAAG;AACxB,iCAAG,QAAQ,IAAI;AAAA,QACnB,OAAO;AACH,eAAK,QAAQ,IAAI,MAAM,6BAA6B,EAAE,GAAG;AAAA,QAC7D;AAAA,MACJ,OAAO;AACH,aAAK,gBAAgB,IAAI,aAAa;AAAA,UAClC,eAAe;AAAA,UACf,YAAY,oBAAI,IAAI;AAAA,UACpB,SAAS,oBAAI,IAAI,CAAC,EAAE,CAAC;AAAA,QACzB,CAAC;AAAA,MACL;AAAA,IACJ,CAAC;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,2BAAiC;AAC7B,SAAK,MAAM,aAAa,YAAY;AAChC,UAAI,KAAK,iBAAiB,QAAQ,UAAS,kCAAkC;AACzE,aAAK,uBAAuB,QAAQ,OAAK,KAAK,iBAAiB,IAAI,CAAC,CAAC;AACrE,aAAK,uBAAuB,MAAM;AAAA,MACtC,OAAO;AAWH,mBAAW,CAAC,aAAa,qBAAqB,KAAK,KAAK,iBAAiB;AACrE,cAAI,sBAAsB,QAAQ,OAAO,GAAG;AACxC,gBAAI,sBAAsB,eAAe;AACrC,oCAAsB,QAAQ,QAAQ,OAAK,sBAAsB,WAAW,IAAI,CAAC,CAAC;AAAA,YACtF,OAAO;AACH,oBAAM,sBACF,sBAAsB,QAAQ,OAAO,sBAAsB,WAAW;AAC1E,kBACI,sBAAsB,UAAS,oCAC/B,CAAC,YAAY,WAAW,QAAQ,GAClC;AACE,sCAAsB,QAAQ,QAAQ,OAAK;AACvC,wCAAsB,WAAW,IAAI,CAAC;AAAA,gBAC1C,CAAC;AACD,qBAAK,QAAQ,IAAI;AAAA,kBACb,aAAa,UAAS,gCAAgC,cAClD,WACJ,2CAA2C,WAAW;AAAA,gBAC1D;AAEA,sBAAM,KAAK,QAAQ,4BAA4B,GAAG,WAAW,IAAI;AAEjE,2BAAW,KAAK,sBAAsB,YAAY;AAC9C,uBAAK,QAAQ,8BAA8B,CAAC;AAAA,gBAChD;AAAA,cACJ,OAAO;AACH,sCAAsB,QAAQ,QAAQ,OAAK;AACvC,wCAAsB,WAAW,IAAI,CAAC;AACtC,uBAAK,QAAQ,uBAAuB,CAAC;AAAA,gBACzC,CAAC;AAAA,cACL;AAAA,YACJ;AACA,kCAAsB,QAAQ,MAAM;AAAA,UACxC;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ,CAAC;AAAA,EACL;AACJ;AAnIa,UACF,mCAAmC;AADvC,IAAM,WAAN;AAqIA,MAAM,iBAAiB;AAAA,EAI1B,YACI,UACA,OACA,KACF;AACE,SAAK,WAAW;AAChB,SAAK,QAAQ;AACb,SAAK,MAAM;AAAA,EACf;AACJ;",
  "names": ["Events"]
}
