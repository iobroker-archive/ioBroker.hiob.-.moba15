{
  "version": 3,
  "sources": ["../../src/notification/notification_manager.ts"],
  "sourcesContent": ["import { SamartHomeHandyBis } from \"../main\";\nimport { Events, StateChangeEvent } from \"../listener/listener\";\n\nimport {NotificationPack } from \"../server/datapacks\";\nimport { Client } from \"../server/client\";\n\nexport class NotificationManager {\n    adapter: SamartHomeHandyBis;\n    backlog: { [deviceID: string]: string[] } = {};\n    constructor(adapter: SamartHomeHandyBis) {\n        this.adapter = adapter;\n        this.init();\n    }\n\n    private init(): void {\n        this.adapter.listener.on(Events.StateChange, this.onStateChange.bind(this));\n    }\n\n    private async onStateChange(event: StateChangeEvent) : Promise<void> {\n        const match: RegExpMatchArray | null = event.objectID.match(\"(hiob.\\\\d*.devices.)(.*)(.sendNotification)\");\n        if (match && match[2] && !event.ack) {\n            const deviceID = match[2];\n            const clients : Client[] | undefined = this.adapter.server?.getClients(deviceID);\n            //Check if client is connected\n            clients?.forEach(e => {\n                this.sendNotificationLocal(e, deviceID, event.value);\n\n            });\n            if(!clients || clients.length <= 0 ) {\n                this.sendNotificationLocal(this.adapter.server?.getClient(deviceID), deviceID, event.value);\n            }\n            this.adapter.setState(event.objectID, { ack: true });\n        }\n    }\n\n    public async sendNotificationLocal(client: Client | undefined, deviceID: string, notification: string): Promise<void> {\n        if (client != undefined && client?.isConnected) {\n            client.sendMSG(new NotificationPack(false, notification, new Date()).toJSON(), true, true, true);\n        } else {\n            //Store to backlog\n            const currentBacklogState = await this.adapter.getStateAsync(\"devices.\" + deviceID + \".notificationBacklog\");\n            if(currentBacklogState) {\n                let currentBacklogRaw = currentBacklogState.val;\n                if(currentBacklogRaw != undefined && currentBacklogRaw === \"\") {\n                    currentBacklogRaw = \"[]\";\n                }\n                const currentBacklogArray : any[] = JSON.parse(currentBacklogRaw as string);\n                currentBacklogArray.push(notification);\n                if(currentBacklogArray.length > 250) {\n                    currentBacklogArray.shift();\n                }\n                await this.adapter.setStateAsync(\"devices.\" + deviceID + \".notificationBacklog\", JSON.stringify(currentBacklogArray), true);\n            }\n        }\n    }\n\n    public async sendBacklog(client : Client) : Promise<void> {\n        if(client) {\n            if(client.isConnected) {\n                const currentBacklogState = await this.adapter.getStateAsync(\"devices.\" + client.id + \".notificationBacklog\");\n                if(currentBacklogState) {\n                    let currentBacklogRaw = currentBacklogState.val;\n                    if(currentBacklogRaw != undefined && currentBacklogRaw === \"\") {\n                        currentBacklogRaw = \"[]\";\n                    }\n                    const currentBacklogArray : any[] = JSON.parse(currentBacklogRaw as string);\n                    for(const i of currentBacklogArray) {\n                        client.sendMSG(new NotificationPack(false, i, new Date()).toJSON(), true);\n                    }\n                    await this.adapter.setStateAsync(\"devices.\" + client.id + \".notificationBacklog\", JSON.stringify([]), true);\n                }\n            }\n        }\n    }\n}"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,sBAAyC;AAEzC,uBAAgC;AAGzB,MAAM,oBAAoB;AAAA,EAG7B,YAAY,SAA6B;AADzC,mBAA4C,CAAC;AAEzC,SAAK,UAAU;AACf,SAAK,KAAK;AAAA,EACd;AAAA,EAEQ,OAAa;AACjB,SAAK,QAAQ,SAAS,GAAG,uBAAO,aAAa,KAAK,cAAc,KAAK,IAAI,CAAC;AAAA,EAC9E;AAAA,EAEA,MAAc,cAAc,OAAyC;AAlBzE;AAmBQ,UAAM,QAAiC,MAAM,SAAS,MAAM,6CAA6C;AACzG,QAAI,SAAS,MAAM,CAAC,KAAK,CAAC,MAAM,KAAK;AACjC,YAAM,WAAW,MAAM,CAAC;AACxB,YAAM,WAAiC,UAAK,QAAQ,WAAb,mBAAqB,WAAW;AAEvE,yCAAS,QAAQ,OAAK;AAClB,aAAK,sBAAsB,GAAG,UAAU,MAAM,KAAK;AAAA,MAEvD;AACA,UAAG,CAAC,WAAW,QAAQ,UAAU,GAAI;AACjC,aAAK,uBAAsB,UAAK,QAAQ,WAAb,mBAAqB,UAAU,WAAW,UAAU,MAAM,KAAK;AAAA,MAC9F;AACA,WAAK,QAAQ,SAAS,MAAM,UAAU,EAAE,KAAK,KAAK,CAAC;AAAA,IACvD;AAAA,EACJ;AAAA,EAEA,MAAa,sBAAsB,QAA4B,UAAkB,cAAqC;AAClH,QAAI,UAAU,WAAa,iCAAQ,cAAa;AAC5C,aAAO,QAAQ,IAAI,kCAAiB,OAAO,cAAc,oBAAI,KAAK,CAAC,EAAE,OAAO,GAAG,MAAM,MAAM,IAAI;AAAA,IACnG,OAAO;AAEH,YAAM,sBAAsB,MAAM,KAAK,QAAQ,cAAc,aAAa,WAAW,sBAAsB;AAC3G,UAAG,qBAAqB;AACpB,YAAI,oBAAoB,oBAAoB;AAC5C,YAAG,qBAAqB,UAAa,sBAAsB,IAAI;AAC3D,8BAAoB;AAAA,QACxB;AACA,cAAM,sBAA8B,KAAK,MAAM,iBAA2B;AAC1E,4BAAoB,KAAK,YAAY;AACrC,YAAG,oBAAoB,SAAS,KAAK;AACjC,8BAAoB,MAAM;AAAA,QAC9B;AACA,cAAM,KAAK,QAAQ,cAAc,aAAa,WAAW,wBAAwB,KAAK,UAAU,mBAAmB,GAAG,IAAI;AAAA,MAC9H;AAAA,IACJ;AAAA,EACJ;AAAA,EAEA,MAAa,YAAY,QAAiC;AACtD,QAAG,QAAQ;AACP,UAAG,OAAO,aAAa;AACnB,cAAM,sBAAsB,MAAM,KAAK,QAAQ,cAAc,aAAa,OAAO,KAAK,sBAAsB;AAC5G,YAAG,qBAAqB;AACpB,cAAI,oBAAoB,oBAAoB;AAC5C,cAAG,qBAAqB,UAAa,sBAAsB,IAAI;AAC3D,gCAAoB;AAAA,UACxB;AACA,gBAAM,sBAA8B,KAAK,MAAM,iBAA2B;AAC1E,qBAAU,KAAK,qBAAqB;AAChC,mBAAO,QAAQ,IAAI,kCAAiB,OAAO,GAAG,oBAAI,KAAK,CAAC,EAAE,OAAO,GAAG,IAAI;AAAA,UAC5E;AACA,gBAAM,KAAK,QAAQ,cAAc,aAAa,OAAO,KAAK,wBAAwB,KAAK,UAAU,CAAC,CAAC,GAAG,IAAI;AAAA,QAC9G;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AACJ;",
  "names": []
}
