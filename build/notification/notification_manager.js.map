{
  "version": 3,
  "sources": ["../../src/notification/notification_manager.ts"],
  "sourcesContent": ["import type { SamartHomeHandyBis } from '../main';\nimport { Events, type StateChangeEvent } from '../listener/listener';\n\nimport { NotificationPack } from '../server/datapacks';\nimport type { Client } from '../server/client';\n\nexport class NotificationManager {\n    adapter: SamartHomeHandyBis;\n    backlog: { [deviceID: string]: string[] } = {};\n    constructor(adapter: SamartHomeHandyBis) {\n        this.adapter = adapter;\n        this.init();\n    }\n\n    private init(): void {\n        this.adapter.listener.on(Events.StateChange, this.onStateChange.bind(this));\n    }\n\n    private onStateChange(event: StateChangeEvent): void {\n        const match: RegExpMatchArray | null = event.objectID.match('(hiob.\\\\d*.devices.)(.*)(.sendNotification)');\n        if (match && match[2] && !event.ack) {\n            const deviceID = match[2];\n            const clients: Client[] | undefined = this.adapter.server?.getClients(deviceID);\n            //Check if client is connected\n            clients?.forEach(e => {\n                this.sendNotificationLocal(e, deviceID, event.value);\n            });\n            if (!clients || clients.length <= 0) {\n                this.sendNotificationLocal(this.adapter.server?.getClient(deviceID), deviceID, event.value);\n            }\n            this.adapter.setState(event.objectID, { ack: true });\n        }\n    }\n\n    public async sendNotificationLocal(\n        client: Client | undefined,\n        deviceID: string,\n        notification: string,\n    ): Promise<void> {\n        if (client != undefined && client?.isConnected) {\n            client.sendMSG(new NotificationPack(false, notification, new Date()).toJSON(), true, true, true);\n        } else {\n            //Store to backlog\n            const currentBacklogState = await this.adapter.getStateAsync(`devices.${deviceID}.notificationBacklog`);\n            if (currentBacklogState) {\n                let currentBacklogRaw = currentBacklogState.val;\n                if (currentBacklogRaw != undefined && currentBacklogRaw === '') {\n                    currentBacklogRaw = '[]';\n                }\n                const currentBacklogArray: any[] = JSON.parse(currentBacklogRaw as string);\n                currentBacklogArray.push(notification);\n                if (currentBacklogArray.length > 250) {\n                    currentBacklogArray.shift();\n                }\n                await this.adapter.setStateAsync(\n                    `devices.${deviceID}.notificationBacklog`,\n                    JSON.stringify(currentBacklogArray),\n                    true,\n                );\n            }\n        }\n    }\n\n    public async sendBacklog(client: Client): Promise<void> {\n        if (client) {\n            if (client.isConnected) {\n                const currentBacklogState = await this.adapter.getStateAsync(\n                    `devices.${client.id}.notificationBacklog`,\n                );\n                if (currentBacklogState) {\n                    let currentBacklogRaw = currentBacklogState.val;\n                    if (currentBacklogRaw != undefined && currentBacklogRaw === '') {\n                        currentBacklogRaw = '[]';\n                    }\n                    const currentBacklogArray: any[] = JSON.parse(currentBacklogRaw as string);\n                    for (const i of currentBacklogArray) {\n                        client.sendMSG(new NotificationPack(false, i, new Date()).toJSON(), true);\n                    }\n                    await this.adapter.setStateAsync(\n                        `devices.${client.id}.notificationBacklog`,\n                        JSON.stringify([]),\n                        true,\n                    );\n                }\n            }\n        }\n    }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA,sBAA8C;AAE9C,uBAAiC;AAG1B,MAAM,oBAAoB;AAAA,EAG7B,YAAY,SAA6B;AADzC,mBAA4C,CAAC;AAEzC,SAAK,UAAU;AACf,SAAK,KAAK;AAAA,EACd;AAAA,EAEQ,OAAa;AACjB,SAAK,QAAQ,SAAS,GAAG,uBAAO,aAAa,KAAK,cAAc,KAAK,IAAI,CAAC;AAAA,EAC9E;AAAA,EAEQ,cAAc,OAA+B;AAlBzD;AAmBQ,UAAM,QAAiC,MAAM,SAAS,MAAM,6CAA6C;AACzG,QAAI,SAAS,MAAM,CAAC,KAAK,CAAC,MAAM,KAAK;AACjC,YAAM,WAAW,MAAM,CAAC;AACxB,YAAM,WAAgC,UAAK,QAAQ,WAAb,mBAAqB,WAAW;AAEtE,yCAAS,QAAQ,OAAK;AAClB,aAAK,sBAAsB,GAAG,UAAU,MAAM,KAAK;AAAA,MACvD;AACA,UAAI,CAAC,WAAW,QAAQ,UAAU,GAAG;AACjC,aAAK,uBAAsB,UAAK,QAAQ,WAAb,mBAAqB,UAAU,WAAW,UAAU,MAAM,KAAK;AAAA,MAC9F;AACA,WAAK,QAAQ,SAAS,MAAM,UAAU,EAAE,KAAK,KAAK,CAAC;AAAA,IACvD;AAAA,EACJ;AAAA,EAEA,MAAa,sBACT,QACA,UACA,cACa;AACb,QAAI,UAAU,WAAa,iCAAQ,cAAa;AAC5C,aAAO,QAAQ,IAAI,kCAAiB,OAAO,cAAc,oBAAI,KAAK,CAAC,EAAE,OAAO,GAAG,MAAM,MAAM,IAAI;AAAA,IACnG,OAAO;AAEH,YAAM,sBAAsB,MAAM,KAAK,QAAQ,cAAc,WAAW,QAAQ,sBAAsB;AACtG,UAAI,qBAAqB;AACrB,YAAI,oBAAoB,oBAAoB;AAC5C,YAAI,qBAAqB,UAAa,sBAAsB,IAAI;AAC5D,8BAAoB;AAAA,QACxB;AACA,cAAM,sBAA6B,KAAK,MAAM,iBAA2B;AACzE,4BAAoB,KAAK,YAAY;AACrC,YAAI,oBAAoB,SAAS,KAAK;AAClC,8BAAoB,MAAM;AAAA,QAC9B;AACA,cAAM,KAAK,QAAQ;AAAA,UACf,WAAW,QAAQ;AAAA,UACnB,KAAK,UAAU,mBAAmB;AAAA,UAClC;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AAAA,EAEA,MAAa,YAAY,QAA+B;AACpD,QAAI,QAAQ;AACR,UAAI,OAAO,aAAa;AACpB,cAAM,sBAAsB,MAAM,KAAK,QAAQ;AAAA,UAC3C,WAAW,OAAO,EAAE;AAAA,QACxB;AACA,YAAI,qBAAqB;AACrB,cAAI,oBAAoB,oBAAoB;AAC5C,cAAI,qBAAqB,UAAa,sBAAsB,IAAI;AAC5D,gCAAoB;AAAA,UACxB;AACA,gBAAM,sBAA6B,KAAK,MAAM,iBAA2B;AACzE,qBAAW,KAAK,qBAAqB;AACjC,mBAAO,QAAQ,IAAI,kCAAiB,OAAO,GAAG,oBAAI,KAAK,CAAC,EAAE,OAAO,GAAG,IAAI;AAAA,UAC5E;AACA,gBAAM,KAAK,QAAQ;AAAA,YACf,WAAW,OAAO,EAAE;AAAA,YACpB,KAAK,UAAU,CAAC,CAAC;AAAA,YACjB;AAAA,UACJ;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AACJ;",
  "names": []
}
