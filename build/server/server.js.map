{
  "version": 3,
  "sources": ["../../src/server/server.ts"],
  "sourcesContent": ["import * as ws from \"ws\";\nimport * as fs from \"fs\";\nimport { createServer } from \"https\";\nimport * as m from \"../main\";\nimport { Client } from \"./client\";\nimport { DataPack, FirstPingPack } from \"./datapacks\";\nimport { Mutex } from \"async-mutex\";\nexport class Server {\n    certPath: string;\n    keyPath: string;\n    useCert: boolean;\n    port: number;\n    adapter: m.SamartHomeHandyBis;\n    socket: ws.Server | undefined;\n    stoped: boolean = false;\n    clientMutex = new Mutex();\n    conClients: {client: Client, lastPong: boolean}[] = [];\n    messageBacklogForClient: {clientId: string, backlog: any[]}[] = [];\n    pingPongInterval :  ioBroker.Interval | undefined;\n    constructor(\n        port: number = 4500,\n        keyPath: string = \"key.pem\",\n        certPath: string = \"cert.pem\",\n        adapter: m.SamartHomeHandyBis,\n        useCert: boolean = false,\n    ) {\n        this.port = port;\n        this.certPath = certPath;\n        this.keyPath = keyPath;\n        this.adapter = adapter;\n        this.useCert = useCert;\n    }\n\n    startServer(): void {\n        let server;\n\n        if (this.useCert) {\n            server = createServer({\n                cert: fs.readFileSync(this.certPath),\n                key: fs.readFileSync(this.keyPath),\n            });\n            this.adapter.log.info(\"[Server] Starting secure server...\");\n            this.socket = new ws.Server({ server: server });\n        } else {\n            this.adapter.log.info(\"[Server] Starting server...\");\n            this.socket = new ws.Server({ port: this.port });\n        }\n        this.socket.on(\"error\", (e) => {\n            this.adapter.log.info(\"error: \" + e.message);\n            this.adapter.setState(\"info.connection\", false, true);\n        });\n        this.adapter.setState(\"info.connection\", true, true);\n        this.socket.on(\"connection\", (socket: ws.WebSocket, req) => {\n            this.adapter.log.debug(\"Client connected\");\n            this.conClients.push({\n                client: new Client(socket, this, req, this.adapter),\n                lastPong: true,\n            });\n            socket.send(new FirstPingPack().toJSON());\n        });\n        server?.listen(this.port);\n        this.adapter.log.info(\"Server started and is listening on port: \" + this.port);\n        this.stoped = false;\n        this.startPingPong();\n    }\n\n    startPingPong() : void {\n        this.pingPongInterval = this.adapter.setInterval(this.pingAll.bind(this), 15*1000)\n\n    }\n\n    private async pingAll() : Promise<void> {\n        await this.clientMutex.runExclusive(() => {\n            this.conClients = this.conClients.filter( (e) => {\n                if(e.lastPong) {\n                    return true;\n\n                } else {\n                    e.client.onEnd();\n                    let backlog = this.messageBacklogForClient.find(c => c.clientId == e.client.id);\n                    if(!backlog) {\n                       backlog = {clientId: e.client.id!, backlog: []};\n                       this.messageBacklogForClient.push(backlog);\n                    }\n                   e.client.messageHistoryMutex.runExclusive(() => {\n                        backlog.backlog.push(...e.client.messageHistory);\n                    });\n                    //If there are 2 clients \"connected\" at the same time. This could happen for a short period of time\n                    this.sendBacklog(e.client);\n\n                    return false;\n                }\n            })\n\n        });\n        this.adapter.log.debug(\"Size: \" + this.conClients.length.toString());\n\n        this.conClients.forEach(e => {\n            e.lastPong = false;\n            e.client.socket.ping();\n        });\n\n    }\n\n    sendBacklog(client: Client) : void {\n        //TODO: Discuss if this would be thread safe. There should only be one client connected (with the same id), so this should be no problem?\n        const backlog = this.messageBacklogForClient.find(e => e.clientId == client.id);\n        backlog?.backlog.forEach(msg => client.sendMSG(msg, true));\n    }\n\n    broadcastMsg(msg: string): void {\n        //this.webSocketServer.clients.forEach((e) => {});\n        this.conClients\n            .filter((e) => !e.client.onlySendNotification)\n            .forEach((element) => {\n                if (element.client.isConnected) element.client.sendMSG(msg, true);\n            });\n    }\n\n    isConnected(deviceID: string): boolean {\n        return this.conClients.some((c) => c.client.isConnected && c.client.id == deviceID);\n    }\n\n    getClient(deviceID: string): Client | undefined {\n        return this.conClients.find((c) => c.client.isConnected && c.client.id == deviceID)?.client;\n    }\n    getClients(deviceID: string): Client[] {\n        return this.conClients.filter((c) => c.client.isConnected && c.client.id == deviceID).map(e => e.client);\n    }\n\n    stop(): void {\n        this.socket?.close();\n        this.adapter.log.info(\"Server stoped\");\n        this.stoped = true;\n        this.adapter.clearInterval(this.pingPongInterval);\n    }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAoB;AACpB,SAAoB;AACpB,mBAA6B;AAE7B,oBAAuB;AACvB,uBAAwC;AACxC,yBAAsB;AACf,MAAM,OAAO;AAAA,EAYhB,YACI,OAAe,MACf,UAAkB,WAClB,WAAmB,YACnB,SACA,UAAmB,OACrB;AAXF,kBAAkB;AAClB,uBAAc,IAAI,yBAAM;AACxB,sBAAoD,CAAC;AACrD,mCAAgE,CAAC;AAS7D,SAAK,OAAO;AACZ,SAAK,WAAW;AAChB,SAAK,UAAU;AACf,SAAK,UAAU;AACf,SAAK,UAAU;AAAA,EACnB;AAAA,EAEA,cAAoB;AAChB,QAAI;AAEJ,QAAI,KAAK,SAAS;AACd,mBAAS,2BAAa;AAAA,QAClB,MAAM,GAAG,aAAa,KAAK,QAAQ;AAAA,QACnC,KAAK,GAAG,aAAa,KAAK,OAAO;AAAA,MACrC,CAAC;AACD,WAAK,QAAQ,IAAI,KAAK,oCAAoC;AAC1D,WAAK,SAAS,IAAI,GAAG,OAAO,EAAE,OAAe,CAAC;AAAA,IAClD,OAAO;AACH,WAAK,QAAQ,IAAI,KAAK,6BAA6B;AACnD,WAAK,SAAS,IAAI,GAAG,OAAO,EAAE,MAAM,KAAK,KAAK,CAAC;AAAA,IACnD;AACA,SAAK,OAAO,GAAG,SAAS,CAAC,MAAM;AAC3B,WAAK,QAAQ,IAAI,KAAK,YAAY,EAAE,OAAO;AAC3C,WAAK,QAAQ,SAAS,mBAAmB,OAAO,IAAI;AAAA,IACxD,CAAC;AACD,SAAK,QAAQ,SAAS,mBAAmB,MAAM,IAAI;AACnD,SAAK,OAAO,GAAG,cAAc,CAAC,QAAsB,QAAQ;AACxD,WAAK,QAAQ,IAAI,MAAM,kBAAkB;AACzC,WAAK,WAAW,KAAK;AAAA,QACjB,QAAQ,IAAI,qBAAO,QAAQ,MAAM,KAAK,KAAK,OAAO;AAAA,QAClD,UAAU;AAAA,MACd,CAAC;AACD,aAAO,KAAK,IAAI,+BAAc,EAAE,OAAO,CAAC;AAAA,IAC5C,CAAC;AACD,qCAAQ,OAAO,KAAK;AACpB,SAAK,QAAQ,IAAI,KAAK,8CAA8C,KAAK,IAAI;AAC7E,SAAK,SAAS;AACd,SAAK,cAAc;AAAA,EACvB;AAAA,EAEA,gBAAuB;AACnB,SAAK,mBAAmB,KAAK,QAAQ,YAAY,KAAK,QAAQ,KAAK,IAAI,GAAG,KAAG,GAAI;AAAA,EAErF;AAAA,EAEA,MAAc,UAA0B;AACpC,UAAM,KAAK,YAAY,aAAa,MAAM;AACtC,WAAK,aAAa,KAAK,WAAW,OAAQ,CAAC,MAAM;AAC7C,YAAG,EAAE,UAAU;AACX,iBAAO;AAAA,QAEX,OAAO;AACH,YAAE,OAAO,MAAM;AACf,cAAI,UAAU,KAAK,wBAAwB,KAAK,OAAK,EAAE,YAAY,EAAE,OAAO,EAAE;AAC9E,cAAG,CAAC,SAAS;AACV,sBAAU,EAAC,UAAU,EAAE,OAAO,IAAK,SAAS,CAAC,EAAC;AAC9C,iBAAK,wBAAwB,KAAK,OAAO;AAAA,UAC5C;AACD,YAAE,OAAO,oBAAoB,aAAa,MAAM;AAC3C,oBAAQ,QAAQ,KAAK,GAAG,EAAE,OAAO,cAAc;AAAA,UACnD,CAAC;AAED,eAAK,YAAY,EAAE,MAAM;AAEzB,iBAAO;AAAA,QACX;AAAA,MACJ,CAAC;AAAA,IAEL,CAAC;AACD,SAAK,QAAQ,IAAI,MAAM,WAAW,KAAK,WAAW,OAAO,SAAS,CAAC;AAEnE,SAAK,WAAW,QAAQ,OAAK;AACzB,QAAE,WAAW;AACb,QAAE,OAAO,OAAO,KAAK;AAAA,IACzB,CAAC;AAAA,EAEL;AAAA,EAEA,YAAY,QAAuB;AAE/B,UAAM,UAAU,KAAK,wBAAwB,KAAK,OAAK,EAAE,YAAY,OAAO,EAAE;AAC9E,uCAAS,QAAQ,QAAQ,SAAO,OAAO,QAAQ,KAAK,IAAI;AAAA,EAC5D;AAAA,EAEA,aAAa,KAAmB;AAE5B,SAAK,WACA,OAAO,CAAC,MAAM,CAAC,EAAE,OAAO,oBAAoB,EAC5C,QAAQ,CAAC,YAAY;AAClB,UAAI,QAAQ,OAAO;AAAa,gBAAQ,OAAO,QAAQ,KAAK,IAAI;AAAA,IACpE,CAAC;AAAA,EACT;AAAA,EAEA,YAAY,UAA2B;AACnC,WAAO,KAAK,WAAW,KAAK,CAAC,MAAM,EAAE,OAAO,eAAe,EAAE,OAAO,MAAM,QAAQ;AAAA,EACtF;AAAA,EAEA,UAAU,UAAsC;AA3HpD;AA4HQ,YAAO,UAAK,WAAW,KAAK,CAAC,MAAM,EAAE,OAAO,eAAe,EAAE,OAAO,MAAM,QAAQ,MAA3E,mBAA8E;AAAA,EACzF;AAAA,EACA,WAAW,UAA4B;AACnC,WAAO,KAAK,WAAW,OAAO,CAAC,MAAM,EAAE,OAAO,eAAe,EAAE,OAAO,MAAM,QAAQ,EAAE,IAAI,OAAK,EAAE,MAAM;AAAA,EAC3G;AAAA,EAEA,OAAa;AAlIjB;AAmIQ,eAAK,WAAL,mBAAa;AACb,SAAK,QAAQ,IAAI,KAAK,eAAe;AACrC,SAAK,SAAS;AACd,SAAK,QAAQ,cAAc,KAAK,gBAAgB;AAAA,EACpD;AACJ;",
  "names": []
}
